networks:
  vision:
    driver: bridge
    ipam:
      config:
        - subnet: 172.30.10.0/24
          gateway: 172.30.10.1

  macvlan:
    driver: macvlan
    driver_opts:
      parent: ${MACVLAN_PARENT}
    ipam:
      config:
        - subnet: 192.168.1.0/24
          gateway: 192.168.1.1

services:
  camera:
    build:
      context: ./services/camera
    env_file: ./services/camera/.env
    volumes:
      - ./services/camera:/app
    ipc: host
    devices:
      - "${CAM_DEVICE}:${CAM_DEVICE}"
    networks:
      - vision

  gateway:
    build:
      context: ./services/gateway
    env_file: ./services/gateway/.env
    volumes:
      - ./services/gateway:/app
    environment:
      ZMQ_SUB_ENDPOINT: tcp://camera:5555

      # LOCAL: send RTP on the vision network so BOTH host gst-launch and local GCS can receive
      RTP_DST_IP: 172.30.10.255
      RTP_PORT: 5004

      # REMOTE: switch to macvlan LAN (unicast preferred; .255 broadcast optional)
      # RTP_DST_IP: 192.168.1.33
      # RTP_DST_IP: 192.168.1.33 # Nano IP
      # RTP_DST_IP: 172.30.10.3
      # RTP_PORT: 5004
      # RTP_DST_IP: 192.168.1.<remote_receiver>
      # RTP_PORT: 5004
    depends_on:
      - camera
    ipc: host
    networks:
      vision: {}
      macvlan:
        ipv4_address: 192.168.1.50
    ports:
      # keep only if you need gateway's web UI from the host
      - "8082:80/tcp"

  gcs:
    build:
      context: ./services/gcs
    restart: unless-stopped
    volumes:
      - ./services/gcs:/app
    env_file:
      - ./services/gcs/.env
    networks:
      - vision
    ports:
      # publish these so the host can reach the GCS web services
      # (use non-conflicting host ports; your host already has something on 8081)
      - "18000:8000/tcp"  # VIDEO_HTTP_PORT
      - "18100:8100/tcp"  # CONTROL_API_PORT
      - "18081:8081/tcp"  # DASH_PORT


#    command: python run_gcs.py
